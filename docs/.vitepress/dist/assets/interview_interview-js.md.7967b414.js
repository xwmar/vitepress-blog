import{o as n,c as s,d as a}from"./app.0196bd1b.js";const p='{"title":"1. 解释下什么是变量声明提升？","description":"","frontmatter":{},"headers":[{"level":2,"title":"1. 解释下什么是变量声明提升？","slug":"_1-解释下什么是变量声明提升？"},{"level":2,"title":"2. JS 的参数是以什么方式进行传递的？","slug":"_2-js-的参数是以什么方式进行传递的？"},{"level":2,"title":"3. JavaScript垃圾回收是怎么做的？","slug":"_3-javascript垃圾回收是怎么做的？"},{"level":3,"title":"3.1 内存的生命周期","slug":"_3-1-内存的生命周期"},{"level":3,"title":"3.2 垃圾回收算法说明","slug":"_3-2-垃圾回收算法说明"},{"level":3,"title":"3.3 引用计数","slug":"_3-3-引用计数"},{"level":3,"title":"3.4 标记清除算法","slug":"_3-4-标记清除算法"},{"level":2,"title":"4. 谈谈你对 JavaScript 作用域链的理解？","slug":"_4-谈谈你对-javascript-作用域链的理解？"},{"level":2,"title":"5. 谈谈你对闭包的理解？","slug":"_5-谈谈你对闭包的理解？"},{"level":2,"title":"6. JavaScript中数据类型的隐式转换规则(了解)","slug":"_6-javascript中数据类型的隐式转换规则-了解"},{"level":2,"title":"7. 谈谈你对原型链的理解？","slug":"_7-谈谈你对原型链的理解？"},{"level":2,"title":"8. 谈谈对于继承的理解","slug":"_8-谈谈对于继承的理解"},{"level":3,"title":"8.1 继承 - 原型继承","slug":"_8-1-继承-原型继承"},{"level":3,"title":"8.2 继承 - 组合继承","slug":"_8-2-继承-组合继承"},{"level":3,"title":"8.3 继承 - 寄生组合继承","slug":"_8-3-继承-寄生组合继承"},{"level":3,"title":"8.4 es6 - class 实现继承 extends","slug":"_8-4-es6-class-实现继承-extends"},{"level":2,"title":"10. 如何判断是否是数组？","slug":"_10-如何判断是否是数组？"},{"level":2,"title":"9. 谈谈你对this的理解？","slug":"_9-谈谈你对this的理解？"},{"level":2,"title":"12. 箭头函数中的this指向什么？","slug":"_12-箭头函数中的this指向什么？"},{"level":2,"title":"12. Promise 的静态方法","slug":"_12-promise-的静态方法"},{"level":2,"title":"13. 宏任务 微任务 是什么","slug":"_13-宏任务-微任务-是什么"},{"level":2,"title":"14. async/await是什么？","slug":"_14-async-await是什么？"},{"level":2,"title":"15. 相较于 Promise，async/await有何优势？","slug":"_15-相较于-promise，async-await有何优势？"},{"level":2,"title":"15. 深拷贝 浅拷贝","slug":"_15-深拷贝-浅拷贝"}],"relativePath":"interview/interview-js.md","lastUpdated":1625452134941}',t={},o=a('<h2 id="_1-解释下什么是变量声明提升？"><a class="header-anchor" href="#_1-解释下什么是变量声明提升？" aria-hidden="true">#</a> 1. 解释下什么是变量声明提升？</h2><p>变量提升（hoisting），是负责解析执行代码的 JavaScript 引擎的工作方式产生的一个特性。 JS引擎在运行一份代码的时候，会按照下面的步骤进行工作：</p><ol><li>首先，对代码进行预解析，并获取声明的所有变量</li><li>然后，将这些变量的声明语句统一放到代码的最前面</li><li>最后，开始一行一行运行代码</li></ol><p>我们通过一段代码来解释这个运行过程：</p><div class="language-js"><pre><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> \n\n<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span> \n\n<span class="token keyword">function</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> \n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> \n<span class="token punctuation">}</span>\n\n<span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 1</span>\n</code></pre></div><p>上⾯这段代码的实际执⾏顺序为:</p><ol><li>JS引擎将 <code>var a = 1</code> 分解为两个部分：变量声明语句 <code>var a = undefined</code> 和变量赋值语句 <code>a = 1</code></li><li>JS引擎将 <code>var a = undefined</code> 放到代码的最前面，而 <code>a = 1</code> 保留在原地 也就是说经过了转换，代码就变成了:</li></ol><div class="language-js"><pre><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">undefined</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// undefined </span>\n\na <span class="token operator">=</span> <span class="token number">1</span>\n\n<span class="token keyword">function</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> \n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> \n<span class="token punctuation">}</span>\n\n<span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 1</span>\n</code></pre></div><p>变量的这一转换过程，就被称为变量的声明提升。</p><p>而这是不规范, 不合理的, 我们用的 let 就没有这个变量提升的问题</p><h2 id="_2-js-的参数是以什么方式进行传递的？"><a class="header-anchor" href="#_2-js-的参数是以什么方式进行传递的？" aria-hidden="true">#</a> 2. JS 的参数是以什么方式进行传递的？</h2><p>基本数据类型和复杂数据类型的数据在传递时，会有不同的表现。</p><p><strong>基本类型：是值传递</strong>！ 基本类型的传递方式比较简单，是按照 <code>值传递</code> 进行的。</p><div class="language-js"><pre><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span>\n\n<span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> \n  x <span class="token operator">=</span> <span class="token number">10</span>  <span class="token comment">// 并不会改变实参的值</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n<span class="token function">test</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// 10 </span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// 1</span>\n</code></pre></div><p><strong>复杂类型: 传递的是地址! (变量中存的就是地址)</strong><img src="http://pic.qigou.top/image20210705000443.png" alt=""></p><p>来看下面的代码：</p><div class="language-js"><pre><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>\n  count<span class="token operator">:</span> <span class="token number">1</span> \n<span class="token punctuation">}</span>\n\n<span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> \n  x<span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">10</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n<span class="token function">test</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// { count: 10 }</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// { count: 10 }</span>\n</code></pre></div><p>从运行结果来看，函数内改变了参数对象内的 <code>count</code> 后，外部的实参对象 <code>a</code> 的内容也跟着改变了，所以传递的是地址。</p><p>思考题:</p><div class="language-js"><pre><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>\n  count<span class="token operator">:</span> <span class="token number">1</span> \n<span class="token punctuation">}</span><span class="token punctuation">;</span> \n\n<span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> \n  x <span class="token operator">=</span> <span class="token punctuation">{</span> count<span class="token operator">:</span> <span class="token number">20</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> \n<span class="token punctuation">}</span>\n\n<span class="token function">test</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// { count: 20 }</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// { count: 1 }</span>\n</code></pre></div><p><img src="http://pic.qigou.top/image20210705000059.png" alt=""></p><p>我们会发现外部的实参对象 <code>a</code> 并没有因为在函数内对形参的重新赋值而被改变！</p><p>因为当我们直接为这个形参变量重新赋值时，其实只是让形参变量指向了别的堆内存地址，而外部实参变量的指向还是不变的。</p><p>下图展示的是复杂类型参数传递后的状态： <img src="http://pic.qigou.top/imageimage-20210218233241397.png" alt=""> 下图展示的是重新为形参赋值后的状态： <img src="http://pic.qigou.top/imageimage-20210218233343016.png" alt=""></p><h2 id="_3-javascript垃圾回收是怎么做的？"><a class="header-anchor" href="#_3-javascript垃圾回收是怎么做的？" aria-hidden="true">#</a> 3. JavaScript垃圾回收是怎么做的？</h2><p>JS中内存的分配和回收都是自动完成的，内存在不使用的时候会被垃圾回收器自动回收。</p><p>正因为垃圾回收器的存在，许多人认为JS不用太关心内存管理的问题，</p><p>但如果不了解JS的内存管理机制，我们同样非常容易成内存泄漏（内存无法被回收）的情况。</p><h3 id="_3-1-内存的生命周期"><a class="header-anchor" href="#_3-1-内存的生命周期" aria-hidden="true">#</a> 3.1 内存的生命周期</h3><p>JS环境中分配的内存, 一般有如下生命周期：</p><ol><li><p>内存分配：当我们声明变量、函数、对象的时候，系统会自动为他们分配内存</p></li><li><p>内存使用：即读写内存，也就是使用变量、函数等</p></li><li><p>内存回收：使用完毕，由垃圾回收自动回收不再使用的内存</p><p>全局变量一般不会回收, 一般局部变量的的值, 不用了, 会被自动回收掉</p></li></ol><p>内存分配:</p><div class="language-jsx"><pre><code><span class="token comment">// 为变量分配内存</span>\n<span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">11</span>\n<span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token string">&quot;ifcode&quot;</span>\n\n<span class="token comment">// 为对象分配内存</span>\n<span class="token keyword">let</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>\n    age<span class="token operator">:</span> <span class="token number">22</span><span class="token punctuation">,</span>\n    name<span class="token operator">:</span> <span class="token string">&#39;ifcode&#39;</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 为函数分配内存</span>\n<span class="token keyword">function</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre></div><h3 id="_3-2-垃圾回收算法说明"><a class="header-anchor" href="#_3-2-垃圾回收算法说明" aria-hidden="true">#</a> 3.2 垃圾回收算法说明</h3><p>所谓垃圾回收, 核心思想就是如何判断内存是否已经不再会被使用了, 如果是, 就视为垃圾, 释放掉</p><p>下面介绍两种常见的浏览器垃圾回收算法: 引用计数 和 标记清除法</p><h3 id="_3-3-引用计数"><a class="header-anchor" href="#_3-3-引用计数" aria-hidden="true">#</a> 3.3 引用计数</h3><p>IE采用的引用计数算法, 定义“内存不再使用”的标准很简单，就是看一个对象是否有指向它的引用。</p><p>如果没有任何变量指向它了，说明该对象已经不再需要了。</p><div class="language-jsx"><pre><code><span class="token comment">// 创建一个对象person, person指向一块内存空间, 该内存空间的引用数 +1</span>\n<span class="token keyword">let</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>\n    age<span class="token operator">:</span> <span class="token number">22</span><span class="token punctuation">,</span>\n    name<span class="token operator">:</span> <span class="token string">&#39;ifcode&#39;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> p <span class="token operator">=</span> person   <span class="token comment">// 两个变量指向一块内存空间, 该内存空间的引用数为 2</span>\nperson <span class="token operator">=</span> <span class="token number">1</span>       <span class="token comment">// 原来的person对象被赋值为1，对象内存空间的引用数-1,</span>\n                 <span class="token comment">// 但因为p指向原person对象，还剩一个对于对象空间的引用, 所以对象它不会被回收</span>\n\np <span class="token operator">=</span> <span class="token keyword">null</span>         <span class="token comment">// 原person对象已经没有引用，会被回收</span>\n</code></pre></div><p>由上面可以看出，引用计数算法是个简单有效的算法。</p><p><strong>但它却存在一个致命的问题：循环引用。</strong></p><p>如果两个对象相互引用，尽管他们已不再使用，垃圾回收器不会进行回收，导致内存泄露。</p><div class="language-jsx"><pre><code><span class="token keyword">function</span> <span class="token function">cycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">let</span> o1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n    <span class="token keyword">let</span> o2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n    o1<span class="token punctuation">.</span>a <span class="token operator">=</span> o2\n    o2<span class="token punctuation">.</span>a <span class="token operator">=</span> o1 \n    <span class="token keyword">return</span> <span class="token string">&quot;Cycle reference!&quot;</span>\n<span class="token punctuation">}</span>\n\n<span class="token function">cycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n</code></pre></div><p><img src="http://pic.qigou.top/image20210705000856.png" alt=""></p><h3 id="_3-4-标记清除算法"><a class="header-anchor" href="#_3-4-标记清除算法" aria-hidden="true">#</a> 3.4 标记清除算法</h3><p>现代的浏览器已经不再使用引用计数算法了。</p><p>现代浏览器通用的大多是基于标记清除算法的某些改进算法，总体思想都是一致的。</p><p>标记清除法:</p><ul><li><p>标记清除算法将“不再使用的对象”定义为“无法达到的对象”。</p></li><li><p>简单来说，就是从根部（在JS中就是全局对象）出发定时扫描内存中的对象。</p></li><li><p>凡是能从根部到达的对象，都是还需要使用的。那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收。</p></li></ul><p>从这个概念可以看出，无法触及的对象包含了没有引用的对象这个概念（没有任何引用的对象也是无法触及的对象）。</p><p>根据这个概念，上面的例子可以正确被垃圾回收处理了。</p><p>参考文章：<a href="https://www.jianshu.com/p/84a8fd5fa0ee" target="_blank" rel="noopener noreferrer">JavaScript内存管理</a></p><h2 id="_4-谈谈你对-javascript-作用域链的理解？"><a class="header-anchor" href="#_4-谈谈你对-javascript-作用域链的理解？" aria-hidden="true">#</a> 4. 谈谈你对 JavaScript 作用域链的理解？</h2><p>JavaScript 在执⾏过程中会创建一个个的<strong>可执⾏上下⽂</strong>。 (每个函数执行都会创建这么一个可执行上下文)</p><p>每个可执⾏上下⽂的词法环境中包含了对外部词法环境的引⽤，可通过该引⽤来获取外部词法环境中的变量和声明等。</p><p>这些引⽤串联起来，⼀直指向全局的词法环境，形成一个链式结构，被称为作⽤域链。</p><p>简而言之: 函数内部 可以访问到 函数外部作用域的变量, 而外部函数还可以访问到全局作用域的变量,</p><p>这样的变量作用域访问的链式结构, 被称之为作用域链</p><div class="language-js"><pre><code><span class="token keyword">let</span> num <span class="token operator">=</span> <span class="token number">1</span>\n\n<span class="token keyword">function</span> <span class="token function">fn</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">100</span>\n  <span class="token keyword">function</span> <span class="token function">inner</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n  <span class="token function">inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n<span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n</code></pre></div><p>下图为由多个可执行上下文组成的调用栈：</p><ul><li><p>栈最底部为<code>全局可执行上下文</code></p></li><li><p><code>全局可执行上下文</code> 之上有多个 <code>函数可执行上下文</code></p></li><li><p>每个可执行上下文中包含了指向外部其他可执行上下文的引用，直到 <code>全局可执行上下文</code> 时它指向 <code>null</code><img src="http://pic.qigou.top/imageimage-20210218143938843.png" alt=""><img src="http://pic.qigou.top/imageimage-20210306093300970.png" alt=""></p><p>js全局有全局可执行上下文, 每个函数调用时, 有着函数的可执行上下文, 会入js调用栈</p></li></ul><p>每个可执行上下文, 都有者对于外部上下文词法作用域的引用, 外部上下文也有着对于再外部的上下文词法作用域的引用 <strong>=&gt; 就形成了作用域链</strong></p><h2 id="_5-谈谈你对闭包的理解？"><a class="header-anchor" href="#_5-谈谈你对闭包的理解？" aria-hidden="true">#</a> 5. 谈谈你对闭包的理解？</h2><p>这个问题想考察的主要有两个方面：</p><ul><li>对闭包的基本概念的理解</li><li>对闭包的作用的了解</li></ul><p><strong>什么是闭包？</strong></p><p>MDN的官方解释：</p><blockquote><p>闭包是函数和声明该函数的词法环境的组合</p></blockquote><p>更通俗一点的解释是：</p><blockquote><p>内层函数, 引用外层函数上的变量, 就可以形成闭包</p></blockquote><p>需求: 定义一个计数器方法, 每次执行一次函数, 就调用一次进行计数</p><div class="language-js"><pre><code><span class="token keyword">let</span> count <span class="token operator">=</span> <span class="token number">0</span>\n<span class="token keyword">function</span> <span class="token function">fn</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  count<span class="token operator">++</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;fn函数被调用了&#39;</span> <span class="token operator">+</span> count <span class="token operator">+</span> <span class="token string">&#39;次&#39;</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n<span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n</code></pre></div><p>这样不好! count 定义成了全局变量, 太容易被别人修改了, 我们可以利用闭包解决</p><p>闭包实例:</p><div class="language-jsx"><pre><code><span class="token keyword">function</span> <span class="token function">fn</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> count <span class="token operator">=</span> <span class="token number">0</span>\n\n  <span class="token keyword">function</span> <span class="token function">add</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    count<span class="token operator">++</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;fn函数被调用了&#39;</span> <span class="token operator">+</span> count <span class="token operator">+</span> <span class="token string">&#39;次&#39;</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token keyword">return</span> add\n<span class="token punctuation">}</span>\n<span class="token keyword">const</span> addFn <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token function">addFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token function">addFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token function">addFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n</code></pre></div><p><strong>闭包的主要作用是什么？</strong></p><p>在实际开发中，闭包最大的作用就是用来 <strong>变量私有</strong>。</p><p>下面再来看一个简单示例：</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 以 let 声明一个局部变量，而不是 this.name</span>\n  <span class="token comment">// this.name = &#39;zs&#39;     =&gt;  p.name</span>\n  <span class="token keyword">let</span> name <span class="token operator">=</span> <span class="token string">&#39;hm_programmer&#39;</span> <span class="token comment">// 数据私有</span>\n  \n  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> \n    <span class="token keyword">return</span> name\n  <span class="token punctuation">}</span>\n  \n  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">setName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span><span class="token punctuation">{</span> \n    name <span class="token operator">=</span> value\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// new:</span>\n<span class="token comment">// 1. 创建一个新的对象</span>\n<span class="token comment">// 2. 让构造函数的this指向这个新对象</span>\n<span class="token comment">// 3. 执行构造函数</span>\n<span class="token comment">// 4. 返回实例</span>\n<span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// hm_programmer</span>\n\np<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">&#39;Tom&#39;</span><span class="token punctuation">)</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// Tom</span>\n\np<span class="token punctuation">.</span>name <span class="token comment">// 访问不到 name 变量：undefined</span>\n</code></pre></div><p>在此示例中，变量 <code>name</code> 只能通过 Person 的实例方法进行访问，外部不能直接通过实例进行访问，形成了一个私有变量。</p><h2 id="_6-javascript中数据类型的隐式转换规则-了解"><a class="header-anchor" href="#_6-javascript中数据类型的隐式转换规则-了解" aria-hidden="true">#</a> 6. JavaScript中数据类型的隐式转换规则(了解)</h2><p>在if语句、逻辑语句、数学运算逻辑、== 等情况下都可能出现隐式类型转换。</p><p>下表展示了一系列原始值，通过隐式转换成数字、字符串、布尔类型后所得到的值： <img src="http://pic.qigou.top/imageimage-20210218171603780.png" alt=""> 坑: 判断时, 尽量不要用 <code>= =</code> , 要用 <code>= = =</code> ( 两个等号判断, 如果类型不同, 默认会进行隐式类型转换再比较)</p><h2 id="_7-谈谈你对原型链的理解？"><a class="header-anchor" href="#_7-谈谈你对原型链的理解？" aria-hidden="true">#</a> 7. 谈谈你对原型链的理解？</h2><p>要讲清楚这个问题，主要着重这几个方面：</p><ul><li>什么是原型对象</li><li>构造函数, 原型对象, 实例的三角关系图</li><li>原型链如何形成</li></ul><p><img src="http://pic.qigou.top/imageimage-20210306104516852.png" alt=""></p><p><strong>原型对象</strong></p><p>在 JavaScript 中，除去一部分内建函数，绝大多数的函数都会包含有一个叫做 <code>prototype</code> 的属性，指向原型对象，</p><p>基于构造函数创建出来的实例, 都可以共享访问原型对象的属性。</p><p>例如我们的 <code>hasOwnProperty</code>, <code>toString</code> ⽅法等其实是 Obejct 原型对象的方法，它可以被任何对象当做⾃⼰的⽅法来使⽤。</p><p><code>hasOwnProperty</code> 用于判断, 某个属性, 是不是自己的 (还是原型链上的)</p><p>来看一段代码：</p><div class="language-js"><pre><code><span class="token keyword">let</span> person <span class="token operator">=</span> <span class="token punctuation">{</span> \n  name<span class="token operator">:</span> <span class="token string">&quot;Tom&quot;</span><span class="token punctuation">,</span> \n  age<span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span> \n  job<span class="token operator">:</span> <span class="token string">&quot;student&quot;</span>\n<span class="token punctuation">}</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">&quot;name&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// true </span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">&quot;hasOwnProperty&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// false </span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">&quot;hasOwnProperty&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// true</span>\n</code></pre></div><p>可以看到，<code>hasOwnProperty</code> 并不是 <code>person</code> 对象的属性，但是 <code>person</code> 却能调用它。</p><p>那么 <code>person</code> 对象是如何找到 Object 原型中的 <code>hasOwnProperty</code> 的呢？这就要靠原型链的能力了。</p><p>需求: 简单绘制原型三角关系图!</p><p><strong>原型链</strong></p><p>在 JavaScript 中，每个对象中都有一个 <code>__proto__</code> 属性，这个属性指向了当前对象的构造函数的原型。</p><p>对象可以通过自身的 <code>__proto__</code>属性与它的构造函数的原型对象连接起来，</p><p>而因为它的原型对象也有 <code>__proto__</code>，因此这样就串联形成一个链式结构，也就是我们称为的原型链。</p><p><img src="http://pic.qigou.top/imageimage-20210218212449526.png" alt=""></p><h2 id="_8-谈谈对于继承的理解"><a class="header-anchor" href="#_8-谈谈对于继承的理解" aria-hidden="true">#</a> 8. 谈谈对于继承的理解</h2><p><strong>为什么要学习继承 ?</strong></p><p>写的构造函数, 定义了一个类型 (人类), 万一项目非常大, 又有了细化的多个类型 (老师, 工人, 学生)</p><p>学习继承, 可以让多个构造函数之间建立关联, 便于管理和复用</p><p><strong>什么是继承 ?</strong></p><p>继承: 从别人那里, 继承东西过来 (财产, 房产)</p><p>代码层面的继承: 继承一些属性构造的过程和方法</p><h3 id="_8-1-继承-原型继承"><a class="header-anchor" href="#_8-1-继承-原型继承" aria-hidden="true">#</a> 8.1 继承 - 原型继承</h3><p>原型继承: 通过改造原型链, 利用原型链的语法, 实现继承方法!</p><p>分析需求:</p><p>​ 人类, 属性: name, age</p><p>​ 学生, 属性: name, age, className</p><p>​ 工人, 属性: name, age, companyName</p><p>无论学生, 还是工人, =&gt; 都是人类, 所以人类原型上有的方法, 他们都应该要有</p><div class="language-js"><pre><code><span class="token comment">// 1. 定义Person构造函数</span>\n<span class="token keyword">function</span> <span class="token function">Person</span> <span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name\n  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age\n<span class="token punctuation">}</span>\n<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">say</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;人类会说话&#39;</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 2. 定义Student构造函数</span>\n<span class="token keyword">function</span> <span class="token function">Student</span> <span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> className</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name\n  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age\n  <span class="token keyword">this</span><span class="token punctuation">.</span>className <span class="token operator">=</span> className\n<span class="token punctuation">}</span>\n<span class="token comment">// 3. 原型继承: 利用原型链, 继承于父级构造函数, 继承原型上的方法</span>\n<span class="token comment">// 语法: 子构造函数.prototype = new 父构造函数()</span>\n<span class="token class-name">Student</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token class-name">Student</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">study</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;学生在学习&#39;</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> stu <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">&#39;张三&#39;</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">,</span> <span class="token string">&#39;80期&#39;</span><span class="token punctuation">)</span>\nstu<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>stu<span class="token punctuation">)</span>\n</code></pre></div><p><img src="http://pic.qigou.top/imageimage-20210306111112493.png" alt=""></p><h3 id="_8-2-继承-组合继承"><a class="header-anchor" href="#_8-2-继承-组合继承" aria-hidden="true">#</a> 8.2 继承 - 组合继承</h3><p>组合继承有时候也叫伪经典继承，指的是将原型链 和 借用构造函数 call 技术组合到一块，</p><p>从而发挥二者之长的一种继承模式，其背后的思路: <strong>是使用原型链实现对原型属性和方法的继承 (主要是方法)，</strong></p><p><strong>而通过借用构造函数来实现对实例属性构造的继承</strong>。这样既通过在原型上定义方法实现了函数复用，又能保证每个实例都有它的自己的属性。</p><div class="language-js"><pre><code><span class="token comment">// 1. 定义Person构造函数</span>\n<span class="token keyword">function</span> <span class="token function">Person</span> <span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name\n  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age\n<span class="token punctuation">}</span>\n<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">say</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;人类会说话&#39;</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 2. 定义Student构造函数</span>\n<span class="token keyword">function</span> <span class="token function">Student</span> <span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> className</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token function">Person</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> age<span class="token punctuation">)</span> <span class="token comment">// 实现构造属性的继承</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>className <span class="token operator">=</span> className\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 3. 原型继承: 利用原型链, 继承于父级构造函数, 继承原型上的方法</span>\n<span class="token comment">// 语法: 子构造函数.prototype = new 父构造函数()</span>\n<span class="token class-name">Student</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token class-name">Student</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">study</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;学生在学习&#39;</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> stu <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">&#39;张三&#39;</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">,</span> <span class="token string">&#39;80期&#39;</span><span class="token punctuation">)</span>\nstu<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>stu<span class="token punctuation">)</span>\n\n<span class="token comment">// 方法通过 原型继承</span>\n<span class="token comment">// 属性通过 父构造函数的.call(this, name, age)</span>\n</code></pre></div><h3 id="_8-3-继承-寄生组合继承"><a class="header-anchor" href="#_8-3-继承-寄生组合继承" aria-hidden="true">#</a> 8.3 继承 - 寄生组合继承</h3><p>student实例上有 name age, 而原型 <code>__proto__</code>上不需要再有这些属性, 所以利用 Object.create 改装下 Object.create(参数对象)</p><ol><li>Object.create 会创建一个新对象,</li><li>并且这个新对象的<code>__proto__</code> 会指向传入的参数对象</li></ol><div class="language-js"><pre><code><span class="token comment">// 1. 定义Person构造函数</span>\n<span class="token keyword">function</span> <span class="token function">Person</span> <span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name\n  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age\n<span class="token punctuation">}</span>\n<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">say</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;人类会说话&#39;</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 2. 定义Student构造函数</span>\n<span class="token keyword">function</span> <span class="token function">Student</span> <span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> className</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token function">Person</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> age<span class="token punctuation">)</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>className <span class="token operator">=</span> className\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 3. 原型继承: 利用原型链, 继承于父级构造函数, 继承原型上的方法</span>\n<span class="token comment">// 语法: 子构造函数.prototype = new 父构造函数()</span>\n<span class="token class-name">Student</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>\n<span class="token class-name">Student</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">study</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;学生在学习&#39;</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> stu <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">&#39;张三&#39;</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">,</span> <span class="token string">&#39;80期&#39;</span><span class="token punctuation">)</span>\nstu<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>stu<span class="token punctuation">)</span>\n<span class="token comment">// 总结:</span>\n<span class="token comment">// Object.create() 以参数的对象, 作为新建对象的__proto__属性的值, 返回新建的对象</span>\n</code></pre></div><p><img src="http://pic.qigou.top/imageimage-20210306114638139.png" alt=""></p><h3 id="_8-4-es6-class-实现继承-extends"><a class="header-anchor" href="#_8-4-es6-class-实现继承-extends" aria-hidden="true">#</a> 8.4 es6 - class 实现继承 extends</h3><div class="language-jsx"><pre><code><span class="token comment">// 继承关键字 =&gt; extends</span>\n<span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name\n    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age\n  <span class="token punctuation">}</span>\n  <span class="token function">jump</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;会跳&#39;</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">class</span> <span class="token class-name">Teacher</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> lesson</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span> <span class="token comment">// extends 中, 必须调用 super(), 会触发执行父类的构造函数</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>lesson <span class="token operator">=</span> lesson\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;构造函数执行了&#39;</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n  <span class="token function">sayHello</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;会打招呼&#39;</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> teacher1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Teacher</span><span class="token punctuation">(</span><span class="token string">&#39;zs&#39;</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">,</span> <span class="token string">&#39;体育&#39;</span><span class="token punctuation">)</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>teacher1<span class="token punctuation">)</span>\n</code></pre></div><h2 id="_10-如何判断是否是数组？"><a class="header-anchor" href="#_10-如何判断是否是数组？" aria-hidden="true">#</a> 10. 如何判断是否是数组？</h2><p>方法一：使用 <code>toString</code> 方法</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">isArray</span><span class="token punctuation">(</span><span class="token parameter">arg</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\t<span class="token keyword">return</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">&#39;[object Array]&#39;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>\n<span class="token function">isArray</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span>  <span class="token comment">// true</span>\n</code></pre></div><p>方法二：使用 ES6 新增的 <code>Array.isArray</code> 方法</p><div class="language-js"><pre><code><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>\nArray<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token comment">// true</span>\n</code></pre></div><h2 id="_9-谈谈你对this的理解？"><a class="header-anchor" href="#_9-谈谈你对this的理解？" aria-hidden="true">#</a> 9. 谈谈你对this的理解？</h2><p><code>this</code> 是一个在运行时才进行绑定的引用，在不同的情况下它可能会被绑定不同的对象。</p><p><strong>默认绑定</strong> (指向window的情况) (函数调用模式 fn() )</p><p>默认情况下，<code>this</code> 会被绑定到全局对象上，比如在浏览器环境中就为<code>window</code>对象，在node.js环境下为<code>global</code>对象。</p><p>如下代码展示了这种绑定关系：</p><div class="language-js"><pre><code>message <span class="token operator">=</span> <span class="token string">&quot;Hello&quot;</span><span class="token punctuation">;</span> \n\n<span class="token keyword">function</span> <span class="token function">test</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> \n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span> \n<span class="token punctuation">}</span>\n\n<span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// &quot;Hello&quot;</span>\n</code></pre></div><p><strong>隐式绑定</strong> (谁调用, this指向谁) (方法调用模式 obj.fn() )</p><p>如果函数的调用是从对象上发起时，则该函数中的 <code>this</code> 会被自动隐式绑定为对象：</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\tconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span> \n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>\n  message<span class="token operator">:</span> <span class="token string">&quot;hello,world&quot;</span><span class="token punctuation">,</span>\n  test<span class="token operator">:</span> test\n<span class="token punctuation">}</span>\n\nobj<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// &quot;hello,world&quot;</span>\n</code></pre></div><p><strong>显式绑定</strong> (又叫做硬绑定) (上下文调用模式, 想让this指向谁, this就指向谁)</p><p>硬绑定 =&gt; call apply bind</p><p>可以显式的进行绑定：</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\tconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span> \n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> obj1 <span class="token operator">=</span> <span class="token punctuation">{</span>\n  message<span class="token operator">:</span> <span class="token string">&quot;你好世界123&quot;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> obj2 <span class="token operator">=</span> <span class="token punctuation">{</span>\n  message<span class="token operator">:</span> <span class="token string">&quot;你好世界456&quot;</span>\n<span class="token punctuation">}</span>\n\n<span class="token function">test</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// &quot;你好世界123&quot;</span>\n<span class="token function">test</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// &quot;你好世界456&quot;</span>\n</code></pre></div><p><strong>new 绑定</strong> (构造函数模式)</p><p>另外，在使用 <code>new</code> 创建对象时也会进行 <code>this</code> 绑定</p><p>当使用 <code>new</code> 调用构造函数时，会创建一个新的对象并将该对象绑定到构造函数的 <code>this</code> 上：</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">Greeting</span><span class="token punctuation">(</span><span class="token parameter">message</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\t<span class="token keyword">this</span><span class="token punctuation">.</span>message <span class="token operator">=</span> message<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Greeting</span><span class="token punctuation">(</span><span class="token string">&quot;hello,world&quot;</span><span class="token punctuation">)</span>\nobj<span class="token punctuation">.</span>message <span class="token comment">// &quot;hello,world&quot;</span>\n</code></pre></div><p>小测试:</p><div class="language-jsx"><pre><code><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>\n    a<span class="token operator">:</span> <span class="token punctuation">{</span>\n        <span class="token function-variable function">fn</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>\n        <span class="token punctuation">}</span><span class="token punctuation">,</span>\n        b<span class="token operator">:</span> <span class="token number">10</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\nobj<span class="token punctuation">.</span>a<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token keyword">let</span> temp <span class="token operator">=</span> obj<span class="token punctuation">.</span>a<span class="token punctuation">.</span>fn<span class="token punctuation">;</span>\n<span class="token function">temp</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n\n<span class="token comment">// -------------------------------------------------------------</span>\n\n<span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">theName<span class="token punctuation">,</span> theAge</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> theName\n    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> theAge\n<span class="token punctuation">}</span>\n<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayHello</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// 定义函数</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> per <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">&quot;小黑&quot;</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span>\nper<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n</code></pre></div><h2 id="_12-箭头函数中的this指向什么？"><a class="header-anchor" href="#_12-箭头函数中的this指向什么？" aria-hidden="true">#</a> 12. 箭头函数中的this指向什么？</h2><p>箭头函数不同于传统函数，它其实没有属于⾃⼰的 <code>this</code>，</p><p>它所谓的 <code>this</code> 是, 捕获其外层 上下⽂的 <code>this</code> 值作为⾃⼰的 <code>this</code> 值。</p><p>并且由于箭头函数没有属于⾃⼰的 <code>this</code> ，它是不能被 <code>new</code> 调⽤的。</p><p>我们可以通过 Babel 转换前后的代码来更清晰的理解箭头函数:</p><div class="language-js"><pre><code><span class="token comment">// 转换前的 ES6 代码</span>\n<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> \n  <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> \n    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> \n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">===</span> obj<span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span> \n<span class="token punctuation">}</span>\n</code></pre></div><div class="language-js"><pre><code><span class="token comment">// 转换后的 ES5 代码</span>\n<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> \n  <span class="token function-variable function">test</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token function">getArrow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> \n    <span class="token keyword">var</span> that <span class="token operator">=</span> <span class="token keyword">this</span>\n    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> \n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>that <span class="token operator">===</span> obj<span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span> \n<span class="token punctuation">}</span>\n</code></pre></div><p>这里我们看到，箭头函数中的 <code>this</code> 就是它上层上下文函数中的 <code>this</code>。</p><h2 id="_12-promise-的静态方法"><a class="header-anchor" href="#_12-promise-的静态方法" aria-hidden="true">#</a> 12. Promise 的静态方法</h2><p>promise的三个状态: pending(默认) fulfilled(成功) rejected(失败)</p><ol><li>resolve函数被执行时, 会将promise的状态从 pending 改成 fulfilled 成功</li><li>reject函数被执行时, 会将promise的状态从pending 改成 rejected 失败</li></ol><p>Promise.reject()</p><div class="language-js"><pre><code><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n\t<span class="token function">reject</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre></div><p>Promise.resolve()</p><div class="language-jsx"><pre><code><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n\t<span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre></div><p><strong>Promise.all([promise1, promise2, promise3])</strong> 等待原则, 是在所有promise都完成后执行, 可以用于处理一些<code>并发的任务</code></p><div class="language-jsx"><pre><code><span class="token comment">// 后面的.then中配置的函数, 是在前面的所有promise都完成后执行, 可以用于处理一些并发的任务</span>\nPromise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>promise1<span class="token punctuation">,</span> promise2<span class="token punctuation">,</span> promise3<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">values</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  <span class="token comment">// values 是一个数组, 会收集前面promise的结果 values[0] =&gt; promise1的成功的结果</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre></div><p>Promise.race([promise1, promise2, promise3]) 赛跑, 竞速原则, 只要三个promise中有一个满足条件, 就会执行.then(用的较少) <img src="http://pic.qigou.top/image20210705002718.png" alt=""></p><h2 id="_13-宏任务-微任务-是什么"><a class="header-anchor" href="#_13-宏任务-微任务-是什么" aria-hidden="true">#</a> 13. 宏任务 微任务 是什么</h2><p>小例题:</p><div class="language-jsx"><pre><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>\n\n<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\tconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>\n</code></pre></div><p>宏任务: 主线程代码, setTimeout 等属于宏任务, 上一个宏任务执行完, 才会考虑执行下一个宏任务</p><p>微任务: promise .then .catch的需要执行的内容, 属于微任务, 满足条件的微任务, 会被添加到当前宏任务的最后去执行</p><p><img src="http://pic.qigou.top/imageimage-20201208040306978.png" alt=""></p><p><strong>事件循环队列 eventLoop</strong></p><p><img src="http://pic.qigou.top/imageimage-20201208040235602.png" alt=""></p><p>例题1:</p><div class="language-jsx"><pre><code>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>\n\n  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">// 宏任务</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>\n\n  <span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">data</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>  <span class="token comment">// 微任务</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>\n</code></pre></div><p><img src="http://pic.qigou.top/imageimage-20210306151137688.png" alt=""></p><p>例题2:</p><div class="language-jsx"><pre><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">fn</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">111</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n<span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">222</span><span class="token punctuation">)</span>\n</code></pre></div><p>例题3:</p><div class="language-jsx"><pre><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">fn</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token number">2</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n<span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">222</span><span class="token punctuation">)</span>\n</code></pre></div><p>例题4:</p><div class="language-jsx"><pre><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">fn</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;嘿嘿&#39;</span><span class="token punctuation">)</span>\n  <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fn2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>  <span class="token comment">// 微任务</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">fn2</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;gaga&#39;</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n<span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">222</span><span class="token punctuation">)</span>\n</code></pre></div><p><img src="http://pic.qigou.top/image20210705003049.png" alt=""></p><p>考察点: async 函数只有从 await 往下才是异步的开始</p><h2 id="_14-async-await是什么？"><a class="header-anchor" href="#_14-async-await是什么？" aria-hidden="true">#</a> 14. async/await是什么？</h2><p>ES7 标准中新增的 <code>async</code> 函数，从目前的内部实现来说其实就是 <code>Generator</code> 函数的语法糖。</p><p>它基于 Promise，并与所有现存的基于Promise 的 API 兼容。 <strong>async 关键字</strong></p><ol><li><p><code>async</code> 关键字用于声明⼀个异步函数（如 <code>async function asyncTask1() {...}</code>）</p></li><li><p><code>async</code> 会⾃动将常规函数转换成 Promise，返回值也是⼀个 Promise 对象</p></li><li><p><code>async</code> 函数内部可以使⽤ <code>await</code></p></li></ol><p><strong>await 关键字</strong></p><ol><li><p><code>await</code> 用于等待异步的功能执⾏完毕 <code>var result = await someAsyncCall()</code></p></li><li><p><code>await</code> 放置在 Promise 调⽤之前，会强制async函数中其他代码等待，直到 Promise 完成并返回结果</p></li><li><p><code>await</code> 只能与 Promise ⼀起使⽤</p></li><li><p><code>await</code> 只能在 <code>async</code> 函数内部使⽤</p></li></ol><h2 id="_15-相较于-promise，async-await有何优势？"><a class="header-anchor" href="#_15-相较于-promise，async-await有何优势？" aria-hidden="true">#</a> 15. 相较于 Promise，async/await有何优势？</h2><ol><li>同步化代码的阅读体验（Promise 虽然摆脱了回调地狱，但 then 链式调⽤的阅读负担还是存在的）</li><li>和同步代码更一致的错误处理方式（ async/await 可以⽤成熟的 try/catch 做处理，比 Promise 的错误捕获更简洁直观）</li><li>调试时的阅读性, 也相对更友好</li></ol><h2 id="_15-深拷贝-浅拷贝"><a class="header-anchor" href="#_15-深拷贝-浅拷贝" aria-hidden="true">#</a> 15. 深拷贝 浅拷贝</h2><p>引用类型, 进行赋值时, 赋值的是地址</p><ol><li><p>浅拷贝</p><div class="language-jsx"><pre><code><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>\n\tname<span class="token operator">:</span> <span class="token string">&#39;zs&#39;</span><span class="token punctuation">,</span>\n\tage<span class="token operator">:</span> <span class="token number">18</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">let</span> obj2 <span class="token operator">=</span> <span class="token punctuation">{</span>\n    <span class="token operator">...</span>obj\n<span class="token punctuation">}</span>\n</code></pre></div></li><li><p>深拷贝</p><div class="language-jsx"><pre><code><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>\n\tname<span class="token operator">:</span> <span class="token string">&#39;zs&#39;</span><span class="token punctuation">,</span>\n\tage<span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span>\n    car<span class="token operator">:</span> <span class="token punctuation">{</span>\n        brand<span class="token operator">:</span> <span class="token string">&#39;宝马&#39;</span><span class="token punctuation">,</span>\n        price<span class="token operator">:</span> <span class="token number">100</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> obj2 <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span>\n</code></pre></div><p>当然递归也能解决, 只是比较麻烦~</p><p>...</p></li></ol><p>其他方案, 可以参考一些博客</p>',204);t.render=function(a,p,t,e,c,l){return n(),s("div",null,[o])};export default t;export{p as __pageData};
